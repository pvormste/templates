{{ if .Auth.Enabled -}}
import base64 from 'base64-js';
{{ end }}{{ range $i, $enum := .Models.Enums }}
export const {{ $enum.Name }} = {
{{ range $j, $value := $enum.Values}}    {{ $value }}: '{{ $value }}',
{{ end }}}
{{ end }}
const FetchMethod = {
    GET: 'GET',
    POST: 'POST',
}

export class Client {
    constructor(endpoint) {
        this.issuer = endpoint;
        {{- if .Client.IsDefined }}
        this.client_id = "{{ .Client.ID }}";
        this.application_id = "{{ .ApplicationID }}";
        this.scopes = "openid+profile+email+offline_access";
        this.access_token = "";
        this.refresh_token = "";
        {{- end }}
    }
    doFetch = async (config) => {
        const params = config.variables === undefined ? "" :
            "?variables=" + encodeURIComponent(JSON.stringify(config.variables))
        const response = await fetch(this.issuer + "/" + this.application_id + "/" + config.operation_name + params, {
            headers: !config.requires_authentication ? undefined : {
                Authorization: "Bearer " + this.access_token,
            },
            method: config.method,
            signal: config.abort_signal,
        });
        return response.json();
    }{{ range $i, $operationData := .OperationsData }}
    {{ $operationData.Operation.OperationPrefix }}{{ $operationData.Operation.Name }} = async ({{ if $operationData.Operation.HasVariables }}variables, {{ end }}requestConfig) => {
        const config = {
            operation_name: "{{ $operationData.Operation.Name }}",
            method: {{ if $operationData.Operation.IsMutation }}FetchMethod.POST{{ else }}FetchMethod.GET{{ end }},
            requires_authentication: {{ $operationData.Operation.Auth.Enabled }},
            abort_signal: requestConfig?.abort_signal,
{{- if $operationData.Operation.HasVariables }}
            variables{{ end }}
        };
        return this.doFetch(config);
    }{{ end }}
{{- if .Client.IsDefined }}
    login = async () => {
        const verifier = this.generateCodeVerifier(96);
        const hash = await this.sha256(verifier);
        let hashBytes = new Uint8Array(hash);
        const challenge = base64.fromByteArray(hashBytes)
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
        sessionStorage.setItem("verifier", verifier);

        const stateData = await this.sha256(this.generateCodeVerifier(96));
        const state = base64.fromByteArray(new Uint8Array(stateData))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
        sessionStorage.setItem("state", state)

        const nonceData = await this.sha256(this.generateCodeVerifier(96));
        const nonce = base64.fromByteArray(new Uint8Array(nonceData))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
        sessionStorage.setItem("nonce", nonce)

        const redirectURI = document.location.toString();
        sessionStorage.setItem("redirectURI", redirectURI)

        window.location.assign(`${this.issuer}/${this.application_id}/_auth/auth?client_id=${this.client_id}&scope=${this.scopes}&redirect_uri=${redirectURI}&nonce=${nonce}&state=${state}&response_type=code&code_challenge=${challenge}`)
    }
    isLoggedIn = () => {
        return this.access_token !== "";
    }
    logout = () => {
        this.access_token = "";
        this.refresh_token = "";
    }
    generateRandomData = (len) => {
        let array = null;
        let crypto = window.crypto || window.msCrypto;
        if (crypto && crypto.getRandomValues && window.Uint8Array) {
            array = new Uint8Array(len);
            crypto.getRandomValues(array);
            return array;
        }
        array = new Array(len);
        for (let j = 0; j < array.length; j++) {
            array[j] = Math.floor(256 * Math.random());
        }
        return array;
    }
    generateCodeVerifier = (len) => {
        return this.generateRandomString(len, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789');
    }
    generateRandomString = (len, alphabet) => {
        let randomData = this.generateRandomData(len);
        let chars = new Array(len);
        for (let i = 0; i < len; i++) {
            chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);
        }
        return String.fromCharCode.apply(null, chars);
    }
    exchangeCodeForToken = async () => {
        let params = new URLSearchParams(document.location.search.substring(1));
        const code = params.get("code");
        const state = params.get("state");
        if (code === null || state === null) {
            return
        }
        const sessionState = sessionStorage.getItem("state");
        if (sessionState !== state) {
            return
        }
        let headers = new Headers();
        headers.append("content-type", "application/x-www-form-urlencoded");
        let fetchTokenParams = new URLSearchParams();
        fetchTokenParams.append("grant_type", "authorization_code");
        fetchTokenParams.append("client_id", this.client_id);
        fetchTokenParams.append("code", code);
        fetchTokenParams.append("redirect_uri", sessionStorage.getItem("redirectURI") || "");
        fetchTokenParams.append("code_verifier", sessionStorage.getItem("verifier") || "");
        fetchTokenParams.append("code_challenge_method", "S256");
        await this.fetchToken(fetchTokenParams,headers)
        window.history.replaceState({}, document.title, document.location.pathname);
    }
    fetchToken = async (searchParams, headers) => {
        const response = await fetch(`${this.issuer}/${this.application_id}/_auth/token`, {
            method: 'POST',
            headers: headers,
            body: searchParams,
            redirect: "follow"
        });
        const data = await response.json();
        if (!this.nonceValid(data.id_token)){
            return
        }
        this.access_token = data.access_token;
        this.refresh_token = data.refresh_token;
        this.scheduleRefresh(data.expires_in);
    }
    scheduleRefresh = (expires_in) => {
        if (this.refresh_timeout_id !== undefined) {
            clearTimeout(this.refresh_timeout_id)
        }
        const refreshingIn = expires_in * 1000 * 0.75;
        this.refresh_timeout_id = setTimeout(async () => {
            await this.refresh()
        }, refreshingIn)
    }
    refresh = async () => {
        if (this.refresh_token === ""){
            return
        }
        let headers = new Headers();
        headers.append("content-type", "application/x-www-form-urlencoded");
        let fetchTokenParams = new URLSearchParams();
        fetchTokenParams.append("grant_type", "refresh_token");
        fetchTokenParams.append("client_id", this.client_id);
        fetchTokenParams.append("refresh_token", this.refresh_token);
        await this.fetchToken(fetchTokenParams,headers)
    }
    sha256 = async (message) => {
        const encoder = new TextEncoder();
        const data = encoder.encode(message);
        return await crypto.subtle.digest('SHA-256', data);
    }
    nonceValid = (id_token) => {
        const data = JSON.parse(atob(id_token.split('.')[1]));
        return data.nonce === sessionStorage.getItem("nonce");
    }
    {{- end }}
}